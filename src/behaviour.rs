//! This module contains everything that is needed in order for the network
//! to function. This includes network event handling, keeping track of network
//! state, and the actual NetworkBehaviour. This is also where most of the libp2p
//! code will live.
use libp2p::{
    PeerId, autonat,
    gossipsub::{self, MessageAuthenticity},
    identify::{self, Info},
    identity::Keypair,
    mdns, relay,
    rendezvous::{self, Cookie, Registration},
    swarm::{NetworkBehaviour, behaviour::toggle::Toggle, dial_opts::DialOpts},
};
use tracing::{error, info, warn};

pub const PROGRAM_PROTOCOL: &str = "magic-test/0.0.1";
pub const RENDEZVOUS_PROTOCOL: &str = "/rendezvous/1.0.0";

pub struct NetworkInfo {
    rendezvous_servers: Vec<PeerId>,
    // relay_servers: Vec<PeerId>,
}

impl NetworkInfo {
    pub fn new() -> Self {
        Self {
            rendezvous_servers: Vec::new(),
            // relay_servers: Vec::new(),
        }
    }
    /// Takes `Info` generated by identify and uses that to figure out if we may need the peers services later
    pub fn regester_server(&mut self, server: PeerId, info: Info) {
        for proto in info.protocols {
            if proto.to_string() == RENDEZVOUS_PROTOCOL {
                self.rendezvous_servers.push(server);
            }
        }
    }
    pub fn get_rendezvous(&self) -> &[PeerId] {
        &self.rendezvous_servers[..]
    }
}

#[derive(NetworkBehaviour)]
pub struct MainBehaviour {
    pub identify: identify::Behaviour,
    pub gossipsub: gossipsub::Behaviour,
    pub rendezvous: rendezvous::client::Behaviour,
    pub autonat: autonat::v2::client::Behaviour,
    pub relay: relay::Behaviour,

    pub mdns: Toggle<mdns::tokio::Behaviour>,
}

impl MainBehaviour {
    pub fn new(keys: &Keypair, has_mdns: bool) -> Self {
        let peer_id = keys.public().to_peer_id();

        let identify_cfg =
            identify::Config::new_with_signed_peer_record(PROGRAM_PROTOCOL.to_string(), keys);
        let identify = identify::Behaviour::new(identify_cfg);

        let rendezvous = rendezvous::client::Behaviour::new(keys.clone());

        let gossipsub_cfg = gossipsub::ConfigBuilder::default().build().unwrap();
        let gossipsub =
            gossipsub::Behaviour::new(MessageAuthenticity::Signed(keys.clone()), gossipsub_cfg)
                .unwrap();

        let autonat = autonat::v2::client::Behaviour::default();

        let relay_cfg = relay::Config::default();
        let relay = relay::Behaviour::new(peer_id, relay_cfg);

        let mdns = if has_mdns {
            let mdns_cfg = mdns::Config::default();
            let mdns = mdns::tokio::Behaviour::new(mdns_cfg, peer_id).unwrap();
            Toggle::from(Some(mdns))
        } else {
            Toggle::from(None)
        };

        Self {
            identify,
            gossipsub,
            rendezvous,
            autonat,
            relay,
            mdns,
        }
    }
    pub fn get_peers(&mut self, node: &PeerId) {
        self.rendezvous.discover(None, None, None, *node);
    }
}

pub enum SwarmOpts {
    Mdns(Vec<DialOpts>),
    Disconnect(PeerId),
    Rendezvous(Vec<Registration>, Cookie),
}

pub fn behaviour_handle(event: MainBehaviourEvent) -> Option<SwarmOpts> {
    // This is for the events that can't update the routing table
    match event {
        MainBehaviourEvent::Gossipsub(e) => match e {
            gossipsub::Event::Message {
                propagation_source,
                message,
                ..
            } => {
                println!(
                    "#{} <{}> {}",
                    message.topic,
                    propagation_source,
                    String::from_utf8_lossy(&message.data)
                );
                None
            }
            gossipsub::Event::Subscribed { peer_id, topic } => {
                println!("#{} <{}> Connected", topic, peer_id);
                None
            }
            gossipsub::Event::Unsubscribed { peer_id, topic } => {
                println!("#{} <{}> Disconnected", topic, peer_id);
                None
            }
            _ => None,
        },
        MainBehaviourEvent::Identify(e) => match e {
            identify::Event::Received {
                connection_id,
                peer_id,
                info,
            } => {
                info!(target: "identify", "Found peer {}: supports {:#?}", peer_id, info.protocols);
                None
            }
            identify::Event::Error {
                connection_id,
                peer_id,
                error,
            } => {
                error!(target: "identify", "Error with {} getting peer info: {}", peer_id, error);
                None
            }
            _ => None,
        },
        MainBehaviourEvent::Mdns(e) => match e {
            mdns::Event::Discovered(list) => {
                let mut dials = Vec::new();
                for (peer_id, addr) in list {
                    info!(target: "mDNS", "Adding {}", peer_id);

                    let dial = DialOpts::peer_id(peer_id).addresses(vec![addr]).build();
                    dials.push(dial);
                }
                Some(SwarmOpts::Mdns(dials))
            }
            mdns::Event::Expired(list) => {
                // This needs more testing to see if we need explicitly remove the addr
                for (peer_id, _) in list {
                    info!(target: "mDNS", "Removing {}", peer_id);
                }
                None
            }
        },
        MainBehaviourEvent::Rendezvous(e) => match e {
            rendezvous::client::Event::Discovered {
                registrations,
                cookie,
                ..
            } => Some(SwarmOpts::Rendezvous(registrations, cookie)),
            rendezvous::client::Event::Registered {
                rendezvous_node,
                ttl,
                namespace,
            } => {
                info!(target: "rendezvous", ttl, "Regestered on {} to <{}>", namespace, rendezvous_node );
                None
            }
            rendezvous::client::Event::DiscoverFailed {
                rendezvous_node,
                error,
                ..
            } => {
                error!(target: "rendezvous", "Discover failed on <{}>: {:?}", rendezvous_node, error);
                None
            }
            _ => None,
        },
        _ => None,
    }
}
