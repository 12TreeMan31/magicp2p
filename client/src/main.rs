use cursive::traits::*;
use cursive::views::{EditView, LinearLayout, TextView};
use cursive::{CbSink, Cursive, CursiveExt, style::Palette, theme, view};
use futures::{AsyncReadExt, StreamExt};
use libp2p::swarm::{Stream, Swarm, SwarmEvent, dial_opts::DialOpts};
use libp2p::{Multiaddr, PeerId, SwarmBuilder, request_response as reqres};
use magicp2p::socket::*;
use scanf::sscanf;
use std::str;
use std::thread;
use tokio::sync::mpsc;
use tokio::{runtime, select};

// Where the user is typeing
const INPUT_BOX: &str = "input_box";
// Where messages are displayed
const CHAT_DISPLAY: &str = "chat_display";

enum SocketOpts {
    ServerLost(PeerId),
    ServerFound(PeerId),
}

/// Builds the cursive runtime and configures the UI layout and theme.
///
/// `client_tx` will send messages generated by `INPUT_BOX` to be processed by the network
fn setup_layout(client_tx: mpsc::UnboundedSender<String>) -> Cursive {
    let mut siv = Cursive::default();
    siv.set_window_title("magic_circle");
    siv.set_theme(theme::Theme {
        shadow: true,
        borders: theme::BorderStyle::Outset,
        palette: Palette::terminal_default(),
    });

    // Where all the text will be displayed
    let chat_view = TextView::new("Welcome to magic_circle!\n")
        .with_name(CHAT_DISPLAY)
        .scrollable()
        .scroll_strategy(view::ScrollStrategy::StickToBottom);

    // Callbacks for INPUT_BOX
    let on_submit_handle = move |siv: &mut Cursive, text: &str| {
        if text.is_empty() {
            return;
        }

        // Send the text data to be sent over the network
        client_tx.send(text.to_string()).unwrap();

        // Clear the input box
        siv.call_on_name(INPUT_BOX, |view: &mut EditView| view.set_content(""));
    };

    // Input box
    let input = EditView::new()
        .on_submit(on_submit_handle)
        .with_name(INPUT_BOX)
        .full_width();

    // Layout: chat area on top, input box at bottom
    let layout = LinearLayout::vertical()
        .child(chat_view.full_height())
        .child(input);

    siv.add_fullscreen_layer(layout);

    siv
}

/// Basic function that appends new text to `CHAT_DISPLAY`
fn update_chat_display(ui_sink: &CbSink, text: String) {
    // It might look like a lot but all we are doing is sending a boxed handler which
    // runs the update display code. This IS thread-safe, the handler is put into a queue
    ui_sink
        .send(Box::new(move |siv| {
            siv.call_on_name(CHAT_DISPLAY, |tv: &mut TextView| {
                let existing = tv.get_content().source().to_string();
                let new_text = format!("{}{}\n", existing, text);
                tv.set_content(new_text);
            });
        }))
        .unwrap();
}

fn command_parse(text: &str) -> Option<RequestEvent> {
    let mut kind: RequestType = RequestType::MESG;
    let mut channel = "".to_string();
    // C <3
    if sscanf!(text, "/{kind} {channel}").is_ok() {
        return Some(RequestEvent {
            kind,
            channel,
            data: None,
        });
    }

    None
}

fn init_swarm(interface: Multiaddr) -> Swarm<SocketBehaviour> {
    let mut swarm = SwarmBuilder::with_new_identity()
        .with_tokio()
        .with_quic()
        .with_behaviour(|_| SocketBehaviour::new_client())
        .expect("Wont fail")
        .build();
    swarm
        .listen_on("/ip4/127.0.0.1/udp/0/quic-v1".parse().unwrap())
        .unwrap();
    // Wrong because 0 is a random port and different from listen on
    // swarm.add_external_address("/ip4/127.0.0.1/udp/0/quic-v1".parse().unwrap());

    let dial = DialOpts::unknown_peer_id().address(interface).build();
    swarm.dial(dial).unwrap();

    swarm
}

// Sorry but libp2p is very much event driven
fn swarm_event_handle(event: SwarmEvent<SocketBehaviourEvent>) -> Option<SocketOpts> {
    match event {
        SwarmEvent::ConnectionEstablished { peer_id, .. } => Some(SocketOpts::ServerFound(peer_id)),
        SwarmEvent::ConnectionClosed { peer_id, .. } => Some(SocketOpts::ServerLost(peer_id)),
        // We don't need to handle the stream event
        SwarmEvent::Behaviour(SocketBehaviourEvent::Socket(event)) => match event {
            reqres::Event::Message { message, .. } => match message {
                reqres::Message::Response { .. } => None,
                _ => unreachable!(), // A request can never be sent to us; see `SocketBehaviour::new_client()`
            },
            reqres::Event::OutboundFailure { .. } => None,
            _ => unreachable!(), // A request can never be sent to us; see `SocketBehaviour::new_client()`
        },
        _ => None,
    }
}

async fn stream_message_handle(mut data: Stream, ui_sink: &CbSink) {
    // Wow, some normal networking code
    let mut buf: Vec<u8> = vec![];

    // messages are so small don't wait till end
    let _ = data.read(&mut buf).await;

    let message = str::from_utf8(&buf).unwrap();

    update_chat_display(ui_sink, message.to_string());
}

/// Event loop the the networking code. It is expected for this to be on its own thread
///
/// `client_rx` gets user input from `TEXT_BOX` while `ui_sink` is to send callbacks to
/// the cursive runtime.
async fn network_manager(mut client_rx: mpsc::UnboundedReceiver<String>, ui_sink: CbSink) {
    let mut swarm: Swarm<SocketBehaviour> = init_swarm(Multiaddr::empty());
    let mut server_id: Option<PeerId> = None;

    // The stream that we will get all messages from
    let mut message_stream = swarm
        .behaviour()
        .new_control()
        .accept(MAGIC_PROTOCOL)
        .expect("Won't fail");

    // Not using functions here since we need to know almost all of the state of the the thread
    let user_input_handle = |text: String| {
        if let Some(_) = command_parse(&text) {
            unimplemented!()
        }

        // Sends message to update the UI next frame
        update_chat_display(&ui_sink, text);
    };
    let mut network_handle = |event: SwarmEvent<SocketBehaviourEvent>| {
        if let Some(e) = swarm_event_handle(event) {
            match e {
                SocketOpts::ServerFound(x) => server_id = Some(x),
                SocketOpts::ServerLost(_) => server_id = None,
            }
        }
    };

    loop {
        select! {
            Some(text) = client_rx.recv() => user_input_handle(text),
            event = swarm.select_next_some() => network_handle(event),
            Some((_, message)) = message_stream.next() => stream_message_handle(message, &ui_sink).await,

        }
    }
}

fn main() {
    let (client_tx, client_rx) = mpsc::unbounded_channel::<String>();

    let mut siv = setup_layout(client_tx);

    // See cb_sink docs for why the fps counter
    siv.set_fps(30);
    // We can clone since its an alias for a crossbeam channel.
    let ui_sink: CbSink = siv.cb_sink().clone();

    thread::spawn(move || {
        let rt = runtime::Builder::new_multi_thread()
            .enable_all()
            .build()
            .expect("Could not start tokio!");

        rt.block_on(network_manager(client_rx, ui_sink));
    });

    siv.run();
}
